/** version:	1.1* date:		2013-04-10** Camera Controller script with barrier detection * for third person aircraft and space ship simulation games.* * Copyright Â© 2013 Make Fire Interactive.** WWW: 		http://make-fire.com* E-Mail:	fire@make-fire.com**/  var target : Transform;var distance : float = 20.0;var height : float = 7.0;var rotationDamping = 2.0;var pivotDamping = 2.0;var fastPivotDampingMultiplyer = 5.0;var maxPositionDiff : float = 7.0;var lookAtDistance : float = 1000.0;var barierTimeout : float = 0.5;private var hitTime : float = 0;@AddComponentMenu("Camera-Control/AircraftCamera")partial class AircraftCamera { }function LateUpdate () {	if (!target)		return;		var currentUp : Vector3 = Quaternion.Lerp(Quaternion.identity, Quaternion.FromToRotation(transform.up,target.up),rotationDamping*Time.deltaTime)*transform.up;	var rotationDiff = Vector3.Angle(currentUp,target.up);		transform.LookAt(target.position+target.forward*lookAtDistance, currentUp);	var currentHeight : float = Mathf.Lerp(height,0,Mathf.Min(1,rotationDiff/90.0));	var pivot : Vector3 = target.up*currentHeight-target.forward*distance;	var wantedPosition : Vector3 = target.position + pivot;		var currentPosition : Vector3 = transform.position;		var hitInfo : RaycastHit;	var pivotDirection : Vector3 = pivot.normalized;	var positionSpeed : float = pivotDamping;	var gotHit : boolean = Physics.Raycast(target.position, pivotDirection, hitInfo, pivot.magnitude);		if (gotHit)	{		hitTime += Time.deltaTime;	}	else	{		hitTime = 0;	}		if (hitTime>barierTimeout)	{		wantedPosition = target.position + pivotDirection*hitInfo.distance;		positionSpeed *= fastPivotDampingMultiplyer;		currentPosition = Vector3.Lerp(currentPosition, wantedPosition, positionSpeed*Time.deltaTime);	}	else	{		var positionDiff : Vector3 = (wantedPosition - currentPosition);		if (maxPositionDiff>0&&(positionDiff.magnitude-maxPositionDiff)>maxPositionDiff*0.01)		{			currentPosition = Vector3.Lerp(wantedPosition, currentPosition, maxPositionDiff/positionDiff.magnitude);		}		else		{			currentPosition = Vector3.Lerp(currentPosition, wantedPosition, positionSpeed*Time.deltaTime);		}	}	transform.position = currentPosition;}